/* spmfilter - mail filtering framework
 * Copyright (C) 2009-2010 Axel Steiner and SpaceNet AG
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef SPMFILTER_H
#define SPMFILTER_H

#include <stdlib.h>

/* spmfilter version */
#define SMF_VERSION ${SMF_VERSION_NUMBER}
#define SMF_MAJOR_VERSION ${SMF_MAJOR_VERSION}
#define SMF_MINOR_VERSION ${SMF_MINOR_VERSION}
#define SMF_MICRO_VERSION ${SMF_MICRO_VERSION}

/* path for spmfilter plugins */
#define LIB_DIR "${SMF_LIB_DIR}"

/* gmime */
#cmakedefine HAVE_GMIME24

/* ldap */
#cmakedefine HAVE_LDAP

/* zdb */
#cmakedefine HAVE_ZDB

typedef struct {
	void (* insert)(int code, char *msg);
	char *(* get)(int code);
} SmtpCodes_T;


typedef struct {
	/* debug flag */
	int debug;
	
	/* path to config file */
	char *config_file;
	
	/* path to spool directory */
	char *queue_dir;
	
	/* configured engine */
	char *engine;
	
	/* all configured modules */
	char **modules;
	
	/* behavior when module fails */
	int module_fail;
	
	/* next smtp hop */
	char *nexthop;
	
	/* smtp code, when delivery to 
	 * nexthop fails */
	int nexthop_fail_code;
	
	/* smtp return message, when delivery
	 * to nexthop fails */
	char *nexthop_fail_msg;
	
	/* configured lookup backend */
	char *backend;

	/* if multiple backend hosts are defined,
	 * it's possible to balance connections
	 * between all, or do failover connections.
	 * possible keys are:
	 * - balance
	 *   load-balance connections among all hosts listed
	 * - failover
	 *   failover connections in the order listed
	 */
	char *backend_connection;
	
	/* hash table for smtp codes */
	SmtpCodes_T *smtp_codes;
	
#ifdef HAVE_ZDB
	char *sql_driver;
	char *sql_name;
	char **sql_host;
	int sql_num_hosts;
	int sql_port;
	char *sql_user;
	char *sql_pass;
	char *sql_user_query;
	char *sql_encoding;
	int sql_max_connections;
#endif

#ifdef HAVE_LDAP
	char *ldap_uri;
	char **ldap_host;
	int ldap_num_hosts;
	int ldap_port;
	char *ldap_binddn;
	char *ldap_bindpw;
	char *ldap_base;
	int ldap_referrals;
	char *ldap_scope;
	char *ldap_user_query;
#endif
} Settings_T;

/* struct for messages send
 * via smtp_delivery */
typedef struct {
	/* message sender */
	char *from;
	
	/* pointer to message recipients */
	char **rcpts;
	
	/* number of recipients */
	int num_rcpts;
	
	/* path to message */
	char *message_file;
	
	/* SMTP auth user, if needed */
	char *auth_user;
	
	/* SMTP auth password, if needed */
	char *auth_pass;
	
	/* destination smtp server */
	char *nexthop;
} Message_T;

typedef struct {
	char *addr;
	int is_local;
} EmailAddress_T;

typedef struct {
	/* hello we received */
	char *helo;
	
	/* recipients */
	EmailAddress_T **rcpts;
	int num_rcpts;
	
	/* sender */
	EmailAddress_T *from;
	
	/* size of message body */
	size_t msgbodysize;
	
	/* this is our spooling file */
	char *queue_file;
	
	/* xfoward */
	char *xforward_addr;
} MailConn_T;

/* Logging and debugging stuff */
typedef enum {
	TRACE_EMERG = 1,
	TRACE_ALERT = 2,
	TRACE_CRIT = 4,
	TRACE_ERR = 8,
	TRACE_WARNING = 16,
	TRACE_NOTICE = 32,
	TRACE_INFO = 64,
	TRACE_DEBUG = 128,
	TRACE_LOOKUP = 256 // Logs at Debug Level
} Trace_T;

/** convenience macro for logging
 *
 * \param level loglevel, see trace_t
 * \param fmt format string for log message
 * \param ... format string arguments
 */
#define TRACE(level, fmt...) trace(level, THIS_MODULE, __func__, __LINE__, fmt)
void trace(Trace_T level, const char * module, const char * function, int line, const char *formatstring, ...);

/** Get all settings
 *
 * \return settings struct
 */
Settings_T *get_settings(void);

/** generate a new queue file name
 *
 * \buf pointer to unallocated buffer for filename, needs to
 *      free'd by caller if not required anymore
 *
 * \returns 0 on success or -1 in case of error
 */
int gen_queue_file(char **tempanme);

/** extract a substring from given string
 * 
 * \param pattern regular expression pattern
 * \param haystack string to search in
 * \param pos position to extract
 *
 * \returns extracted string
 */
char* get_substring(const char *pattern, const char *haystack, int pos);

/** write a message to disk
 *
 * \param new_path path for the new message file
 * \param queue_file path of the queue file
 *
 * \returns 0 on success or -1 in case of error
 */
int write_message(char *new_path, char *queue_file);

/* gets the value of the requested header if it exists
 *
 * \param msg_path path to message or queue file
 * \param header_name name of the wanted header
 *
 * \returns value of header or NULL in case of error
 */
char *get_header(char *msg_path, const char *header_name);

/** Sets an arbitrary header
 * 
 * \param msg_path path to message or queue file
 * \param header_name name of the header
 * \param header_value new value for the header
 *
 * \returns 0 on success or -1 in case of error
 */
int set_header(char *msg_path, char *header_name, char *header_value);

/** Removed the specified header if it exists
 *
 * \param msg_path path to message or queue_file
 * \param header_name name of the header
 *
 * \returns 0 on success or -1 in case of error
 */
int remove_header(char *msg_path, char *header_name);

/** Deliver message
 *
 * \param msg_data Messate_T structure
 *
 * \returns 0 on success or -1 in case of error
 */
int smtp_delivery(Message_T *msg_data);

/** generates a unique maildir filename
 * 
 * \returns generated filename or NULL in case of error
 */
char *get_maildir_filename(void);

struct lookup_element {
	void *data;
};
typedef struct lookup_element LookupElement_T;

struct lookup_result {
	LookupElement_T *elem;
	struct lookup_result *next;
	struct lookup_result *prev;
};
typedef struct lookup_result LookupResult_T;

/** Since LDAP attributes can have more than
 *  one value, we need to define a new datatype,
 *  in order not to link every module against
 *  ldap, which needs LDAP connectivity.
 *  Every LDAP lookup returns LookupElement_T
 *  with LdapValue_T pointer as data.
 */
typedef struct {
	int num_values;
	char **values;
} LdapValue_T;

/** Allocates memory for LookupResult_T
 *
 * \returns newly allocated LookupResult_T
 */
LookupResult_T *lookup_result_new(void);

/** Frees all of the memory used by LookupResult_T
 *
 * \param *l pointer to LookupResult_T
 */
void lookup_result_free(LookupResult_T *l);

/** Adds a new element on to the end of the list.
 *  The return value is the new start of the list,
 *  which may have changed, so make sure you store the new value.
 *
 * \param *l pointer to LookupResult_T
 * \param *elem_data pointer to LookupElement_T
 *
 * \returns the new start of LookupResult_T
 */
LookupResult_T *lookup_result_append(LookupResult_T *l, LookupElement_T *elem_data);

/** Get the first element of LookupResult_T
 *
 * \param *l pointer to LookupResult_T
 *
 * \returns the first element in LookupResult_T,
 *          or NULL if there are no elements
 */
LookupResult_T *lookup_result_first(LookupResult_T *l);

/** Get the last element of LookupResult_T
 *
 * \param *l pointer to LookupResult_T
 *
 * \returns the first element in LookupResult_T,
 *          or NULL if there are no elements
 */
LookupResult_T *lookup_result_last(LookupResult_T *l);

/** Get the previous element of LookupResult_T
 *
 * \param *l pointer to LookupResult_T
 *
 * \returns the previous element, or NULL if there are no previous elements.
 */
LookupResult_T *lookup_result_previous(LookupResult_T *l);

/** Get the next element of LookupResult_T
 *
 * \param *l pointer to LookupResult_T
 *
 * \returns the next element, or NULL if there is no following element
 */
LookupResult_T *lookup_result_next(LookupResult_T *l);

/** Get the element at the given position
 *
 * \param *l pointer to LookupResult_T
 * \param i the position of the element
 *
 * \returns the element, or NULL if the position is off the end
 */
LookupResult_T *lookup_result_nth(LookupResult_T *l, int i);

/** This function iterates over the whole list to count its elements.
 *
 * \param *l pointer to LookupResult_T
 *
 * \returns the number of elements
 */
int lookup_result_count(LookupResult_T *l);

/** Looks up a key in LookupResult_T
 *
 * \param *r pointer to LookupResult_T
 * \param *key the key to look up
 *
 * \returns the associated value, or NULL if the key is not found
 */
void *lookup_element_get(LookupResult_T *r, char *key);

/** Establish database/ldap connection
 *
 * \returns 0 on success or -1 in case of error
 */
int lookup_connect(void);

/** Destroy database/ldap connection
 *
 * \returns 0 on success or -1 in case of error
 */
int lookup_disconnect(void);

/** Check if given user is local
 *
 * \param addr email address
 *
 * \returns 0 if user is not local, 1 if
 *          user is local
 */
int lookup_user(char *addr);

LookupResult_T *lookup_query(const char *q, ...);



#endif
