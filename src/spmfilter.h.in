#ifndef SPMFILTER_H
#define SPMFILTER_H

#include <glib.h>
#include <gmime/gmime.h>
#include <sys/time.h>

/* spmfilter version */
#define SMF_VERSION ${SMF_VERSION_NUMBER}
#define SMF_MAJOR_VERSION ${SMF_MAJOR_VERSION}
#define SMF_MINOR_VERSION ${SMF_MINOR_VERSION}
#define SMF_MICRO_VERSION ${SMF_MICRO_VERSION}

/* path for spmfilter plugins */
#define LIB_DIR "${SMF_LIB_DIR}"

/* gmime */
#cmakedefine HAVE_GMIME24

/* ldap */
#cmakedefine HAVE_LDAP

/* zdb */
#cmakedefine HAVE_ZDB

#ifdef HAVE_ZDB
#include <URL.h>
#include <ResultSet.h>
#include <PreparedStatement.h>
#include <Connection.h>
#include <ConnectionPool.h>
#include <SQLException.h>
#endif

#ifdef HAVE_LDAP
#include <ldap.h>
#endif

#define GLIB2_VERSION (GLIB_MAJOR_VERSION * 10000 \
	+ GLIB_MINOR_VERSION * 100 \
	+ GLIB_MICRO_VERSION)

#define MATCH(x,y) strcasecmp((x),(y))==0

/* single linked list for 
 * individual smtp return codes */ 
typedef struct smtp_code {
	int code;
	char *message;
	struct smtp_code *next;
} SMTP_CODE;

typedef struct {
	/* debug flag */
	int debug;
	
	/* path to config file */
	char *config_file;
	
	/* path to spool directory */
	char *queue_dir;
	
	/* configured engine */
	char *engine;
	
	/* all configured modules */
	char **modules;
	
	/* behavior when module fails */
	int module_fail;
	
	/* next smtp hop */
	char *nexthop;
	
	/* smtp code, when delivery to 
	 * nexthop fails */
	int nexthop_fail_code;
	
	/* smtp return message, when delivery
	 * to nexthop fails */
	char *nexthop_fail_msg;
	
	/* configured lookup backend */
	char *backend;
	
	/* hash table for smtp codes */
//	GHashTable *smtp_codes;
	SMTP_CODE *smtp_codes;
	
#ifdef HAVE_ZDB
	char *sql_driver;
	char *sql_name;
	char *sql_host;
	int sql_port;
	char *sql_user;
	char *sql_pass;
	char *encoding;
	char *sql_user_query;
	char *sql_encoding;
	int sql_max_connections;
#endif

#ifdef HAVE_LDAP
	char *ldap_uri;
	char *ldap_host;
	int ldap_port;
	char *ldap_binddn;
	char *ldap_bindpw;
	char *ldap_base;
	int ldap_referrals;
#endif
} SETTINGS;

/* struct for messages send
 * via smtp_delivery */
typedef struct {
	/* message sender */
	char *from;
	
	/* pointer to message recipients */
	char **rcpts;
	
	/* number of recipients */
	int num_rcpts;
	
	/* path to message */
	char *message_file;
	
	/* SMTP auth user, if needed */
	char *auth_user;
	
	/* SMTP auth password, if needed */
	char *auth_pass;
	
	/* destination smtp server */
	char *nexthop;
} MESSAGE;

typedef struct {
	char *addr;
	int is_local;
} EMLADDR;

typedef struct {
	/* hello we received */
	char *helo;
	
	/* recipients */
	EMLADDR **rcpts;
	int num_rcpts;
	
	/* sender */
	EMLADDR *from;
	
	/* size of message body */
	size_t msgbodysize;
	
	/* this is our spooling file */
	char *queue_file;
	
	/* xfoward */
	char *xforward_addr;
} MAILCONN;

/* Logging and debugging stuff */
typedef enum {
	TRACE_EMERG = 1,
	TRACE_ALERT = 2,
	TRACE_CRIT = 4,
	TRACE_ERR = 8,
	TRACE_WARNING = 16,
	TRACE_NOTICE = 32,
	TRACE_INFO = 64,
	TRACE_DEBUG = 128,
	TRACE_LOOKUP = 256 // Logs at Debug Level
} trace_t;

/** convenience macro for logging
 *
 * \param level loglevel, see trace_t
 * \param fmt format string for log message
 * \param ... format string arguments
 */
#define TRACE(level, fmt...) trace(level, THIS_MODULE, __func__, __LINE__, fmt)
void trace(trace_t level, const char * module, const char * function, int line, const char *formatstring, ...);
// TODO: need settings->debug in trace()

/** get all settings
 *
 * \return settings struct
 */
SETTINGS *get_settings(void);

void set_settings(SETTINGS **s);

/** free settings struct */
void free_settings(SETTINGS *settings);

/** load and parse config file
 *
 * \returns 0 on success or -1 in case of error
 */

int parse_config(void);

/** generate a new queue file name
 *
 * \buf pointer to unallocated buffer for filename
 *
 * \returns 0 on success or -1 in case of error
 */
int gen_queue_file(char **tempanme);

/** add smtp return code to list
 *
 * \buf pointer to SMTP_CODE struct
 * \param code smtp code 
 * \param message smtp return message
 */
void smtp_code_append(SMTP_CODE **codes, int code, char *message);

/** search smtp message
 *
 * \param codes SMTP_CODE list
 * \param code integer code
 *
 * \returns smtp message for given code
 */
char *smtp_code_lookup(SMTP_CODE *codes, int code);

/** free smtp codes
 *
 * \buf pointer to smtp codes
 */
void smtp_codes_free(SMTP_CODE **codes);

/** extract a substring from given string
 * 
 * \param pattern regular expression pattern
 * \param haystack string to search in
 * \param pos position to extract
 *
 * \returns extracted string
 */
char* get_substring(const char *pattern, const char *haystack, int pos);

/** parse a message file on disk
 *
 * \param msg_path path to message file
 *
 * \returns GMimeMessage object or NULL in case of error
 */
GMimeMessage *parse_message(char *msg_path);

/** write a message to disk
 *
 * \param msg_path path for the new message file
 * \param message GMimeMessage object
 *
 * \returns 0 on success or -1 in case of error
 */
int write_message(char *msg_path, GMimeMessage *message);

/* gets the value of the requested header if it exists
 *
 * \param msg_path path to message or queue file
 * \param header_name name of the wanted header
 *
 * \returns value of header or NULL in case of error
 */
const char *get_header(char *msg_path, char *header_name);

/** adds an arbitrary header to the message
 * 
 * \param msg_path path to message or queue file
 * \param header_name: name of the new header
 * \param header_value value for the new header
 *
 * \returns 0 on success or -1 in case of error
 */
int add_header(char *msg_path, char *header_name, char *header_value);

/** sets an arbitrary header
 * 
 * \param msg_path path to message or queue file
 * \param header_name name of the header
 * \param header_value new value for the header
 *
 * \returns 0 on success or -1 in case of error
 */
int set_header(char *msg_path, char *header_name, char *header_value);

/** removed the specified header if it exists
 *
 * \param msg_path path to message or queue_file
 * \param header_name name of the header
 *
 * \returns 0 on success or -1 in case of error
 */
int remove_header(char *msg_path, char *header_name);

int smtp_delivery(MESSAGE *msg_data);

/** generates a unique maildir filename
 * 
 * \returns generated filename or NULL in case of error
 */
char *get_maildir_filename(void);

#ifdef HAVE_ZDB
/** connect to sql server
 *
 * \returns 0 on success or -1 in case of error
 */
int sql_connect(void);

/** check if given user exists in database
 *
 * \param addr email adress of user
 *
 * \return 1 if the user exists, otherwise 0
 */
int sql_user_exists(char *addr); 

/** do a database query
 *
 * \param q format string for sql query
 * \param ... arguments for format string
 *
 * \returns ResultSet_T or NULL in case of error
 */
ResultSet_T sql_query(const char *q, ...);
#endif

#ifdef HAVE_LDAP
/** connect to ldap server
 *
 * \returns 0 on success or -1 in case of error
 */
int ldap_connect(void);

/** query LDAP directory, returns LDAPMessage
 * 
 * \param q format string for ldap query
 * \param ... arguments for format string
 * 
 * \returns LDAPMessage or NULL in case of error
 */
LDAPMessage *ldap_query(const char *q, ...);

/** check if given user exists in ldap directory
 *
 * \param addr email adress of user
 *
 * \return 1 if the user exists, otherwise 0
 */
int ldap_user_exists(char *addr);
#endif

/** expands placeholders in a user querystring
 *
 * \param format format string to use as input
 * \param addr email address to use for replacements
 * \buf pointer to unallocated buffer for expanded format string, needs to
 *      free'd by caller if not required anymore
 *
 * \returns the number of replacements made or -1 in case of error
 */
int expand_query(char *format, char *addr, char **buf);

#endif
